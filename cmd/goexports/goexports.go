// This program generates code to register binary program symbols to
// the interpeter.
// See export.go for usage

package main

import (
	"bufio"
	"fmt"
	"go/importer"
	"go/types"
	"log"
	"os"
	"os/exec"
	"path"
	"strings"
	"unicode"
)

func genfile(pkgName string, ofile string) error {
	p, err := importer.Default().Import(pkgName)
	if err != nil {
		return err
	}

	f, err := os.Create(ofile)
	if err != nil {
		return err
	}
	defer f.Close()
	out := bufio.NewWriter(f)
	sym := symName(pkgName)
	pkg := path.Base(pkgName)

	// Print header
	fmt.Fprintln(out, `package export
// Generated by 'goexports `+pkgName+`'. Do not edit!

import "`+pkgName+`"

// `+sym+` contains exported symbols from `+pkgName+`
var `+sym+` = &map[string]interface{}{`)

	// Print package exports
	sc := p.Scope()
	for _, name := range sc.Names() {
		// Skip private symboles
		if r := []rune(name); unicode.IsLower(r[0]) || name[0] == '_' {
			continue
		}
		o := sc.Lookup(name)
		switch o.(type) {
		case *types.Const:
			if (pkgName == "math" && name == "MaxUint64") ||
				(pkgName == "hash/crc64" && name == "ECMA") ||
				(pkgName == "hash/crc64" && name == "ISO") {
				// go build will fail with overflow error if this const is untyped. Fix this.
				fmt.Fprintln(out, "\""+name+"\": uint("+pkg+"."+name+"),")
			} else {
				fmt.Fprintln(out, "\""+name+"\": "+pkg+"."+name+",")
			}
		case *types.Func:
			fmt.Fprintln(out, "\""+name+"\": "+pkg+"."+name+",")
		case *types.TypeName:
			// Allocate an addressable/settable zero value from which type can be infered by reflect
			fmt.Fprintln(out, "\""+name+"\": new("+pkg+"."+name+"),")
		case *types.Var:
			fmt.Fprintln(out, "\""+name+"\": "+pkg+"."+name+",")
		}
	}
	fmt.Fprintln(out, "}")
	out.Flush()
	return nil
}

func symName(s string) string {
	var r string
	d, f := path.Split(s)
	if len(d) > 1 {
		r = exportName(path.Base(d[:len(d)-1]))
	}
	return r + exportName(f)
}

// acronyms contains well know uppercase acronyms expected in upper case by golint in variable names
var acronyms = map[string]string{
	"ascii85": "ASCII85",
	"html":    "HTML",
	"http":    "HTTP",
	"json":    "JSON",
	"rpc":     "RPC",
	"smtp":    "SMTP",
	"sql":     "SQL",
	"tls":     "TLS",
	"url":     "URL",
	"xml":     "XML",
}

func exportName(s string) string {
	if acronym, ok := acronyms[s]; ok {
		return acronym
	}
	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

func main() {
	for _, pkg := range os.Args[1:] {
		ofile := "sym_" + strings.Replace(pkg, "/", "_", -1) + ".go"
		if err := genfile(pkg, ofile); err != nil {
			log.Fatal(err)
		}
		if err := exec.Command("gofmt", "-w", ofile).Run(); err != nil {
			log.Fatal(err)
		}
	}
}
