// This program generates code to register binary program symbols to
// the interpeter.
// See stdlib.go for usage

package main

import (
	"bufio"
	"fmt"
	"go/importer"
	"go/types"
	"log"
	"os"
	"os/exec"
	"path"
	"strings"
	"unicode"
)

func genfile(pkgName string, ofile string) error {
	p, err := importer.Default().Import(pkgName)
	if err != nil {
		return err
	}

	f, err := os.Create(ofile)
	if err != nil {
		return err
	}
	defer f.Close()
	out := bufio.NewWriter(f)
	typ := []string{}
	val := []string{}
	pkg := path.Base(pkgName)
	sc := p.Scope()
	for _, name := range sc.Names() {
		// Skip private symboles
		if r := []rune(name); unicode.IsLower(r[0]) || name[0] == '_' {
			continue
		}
		o := sc.Lookup(name)
		switch o.(type) {
		case *types.Const, *types.Func, *types.Var:
			val = append(val, name)
		case *types.TypeName:
			typ = append(typ, name)

		}
	}
	// Print header
	fmt.Fprintln(out, `package stdlib
// Code generated by 'goexports `+pkgName+`'. DO NOT EDIT.

import (
	"`+pkgName+`"
	"reflect"
)

func init() {`)

	// Print values
	fmt.Fprintln(out, `Value["`+pkgName+`"] = map[string]reflect.Value{`)
	for _, v := range val {
		if (pkgName == "math" && v == "MaxUint64") ||
			(pkgName == "hash/crc64" && v == "ECMA") ||
			(pkgName == "hash/crc64" && v == "ISO") {
			// go build will fail with overflow error if this const is untyped. Fix this.
			fmt.Fprintln(out, "\""+v+"\": reflect.ValueOf(uint("+pkg+"."+v+")),")
		} else {
			fmt.Fprintln(out, "\""+v+"\": reflect.ValueOf("+pkg+"."+v+"),")
		}
	}
	fmt.Fprintln(out, "}")

	// Print types
	fmt.Fprintln(out, `Type["`+pkgName+`"] = map[string]reflect.Type{`)
	for _, t := range typ {
		fmt.Fprintln(out, "\""+t+"\": reflect.TypeOf((*"+pkg+"."+t+")(nil)).Elem(),")
	}
	fmt.Fprintln(out, "}")

	fmt.Fprintln(out, "}")
	out.Flush()
	return nil
}

func main() {
	for _, pkg := range os.Args[1:] {
		ofile := strings.Replace(pkg, "/", "_", -1) + ".go"
		if err := genfile(pkg, ofile); err != nil {
			log.Fatal(err)
		}
		if err := exec.Command("gofmt", "-w", ofile).Run(); err != nil {
			log.Fatal(err)
		}
	}
}
